# 상태 관리에 대한 고찰

상태 관리는 무엇일까? 상태 관리라는 말이 따로 나올 정도로 뭔가 대단한 개념일까?
어떤 책에서 이렇게 정의한걸 본 적이 있다. 

`view = f(state)`

모종의 상태가 비지니스 로직을 만나서 변화한 결과를 마크업과 스타일 등을 통해 보여준 것이 view라는 이야기다.그럼 결국 우리가 말하는 상태는 f 라는 비지니스 로직에 들어갈 변수다.

사실 상태라는 개념은 어디서 갑자기 툭 튀어나온 개념이 아니다. 모든 프로그램은 상태를 갖고 있다. 현대 컴퓨터의 모델 자체가 튜링 머신을 기반하고 있기 때문이다. 튜링 머신에 대한 설명을 잠시 하자면, 튜링 머신이란 엘런 튜링이 논문에서 개념적으로 제시한 기계로 단 3가지 요소로 구성되어 있는 기계다. **긴 테이프와, 그 테이프의 내용을 차례대로 읽을 수 있는 헤드, 그리고 자기 자신의 상태를 저장하는 공간**이 바로 그것이다.

헤드는 한 칸씩 이동하며, 테이프에 기록된 내용을 차례대로 읽어서 실행한다. 테이프에는 간단한 명령들이 기록되어있다. 예를 들어 무언갈 더하고, 이동하고, 상태를 바꾸는 것이다. 이렇게 기계를 만들면 테이프에 간단한 명령들을 순차적으로 기록해놓는 것만으로도 모든 수학적 논리들을 표현할 수 있다. 그래서 이 튜링 기계를 바탕으로 설계된 컴퓨터는 P문제 집합 외에는 표현할 수도 해결할 수도 없다.

> P 문제는 **결정 문제들 중 쉽게 풀리는 것을 모아 놓은 집합**
이다. 어떤 결정 문제가 주어졌을 때, 다항식(Polynomial) 시간 이내에 그 문제의 답을 계산해낼 수 있는 알고리즘이 존재한다면, 그 문제는 P 문제에 해당된다.


추상적으로 생각해보면, View에 들어가는 상태 또한 크게 다른 개념은 아니다. 
그렇다면 우리는 왜 상태 관리에 있어서 고통 받을까? 

그럼 다르게 생각해보자. 어떤 상태 관리에 있어 이상적인 요소는 무엇일까?

상태 관리에서 가장 이상적인 구조는 상태와 View가 1:1인 관계이며, 단방향으로 상태가 흐르는 상황이다.
이유인 즉슨 이러하다. 상태의 변화를 보다 손쉽게 예측할 수 있기 때문이다.

우리가 자주 접하는 PC지도를 생각해보자. 

PC지도는 Model View Controller로 구성되어 있는 MVC 패턴을 활용하여 만든 SPA 웹앱이다. 하나의 단일 Model은 API와 통신하여 상태를 업데이트하거나, View와의 상호작용을 통해 자체적으로 가진 상태를 갱신한다. 대부분의 모델이 API와의 통신을 통해 상태를 받아오기만 하며, POST 요청의 경우 Controller 내에서 처리한다.

결국 View는 상태를 변화시키지 않는다. 견해의 차이는 있겠지만, 나는 이러한 점이 PC지도가 오래 같은 구조를 확장해서 지금까지 살아남은 큰 요인 중 하나라고 생각한다. 이러한 단순한 구조가 가능해진 이유는 View의 단위가 모던 프레임워크보다 훨씬 거대했기 때문이다. 

모던 프레임워크에선 어떨까? 나는 개인적으로 모던 프레임워크의 가장 큰 장점이자 단점은 컴포넌트 단위에 보다 쉽게 접근할 수 있게 된 점이라고 생각한다. 굉장히 작은 단위의 심지어 버튼 하나까지도 컴포넌트로 분리해서 관리하는데 어려움을 느끼지 않을 정도로 모던 프레임워크에서의 컴포넌트는 굉장히 유연하다. 

다만 이는 상태 관리에 있어서 또 다른 문제를 낳았다. 거대 컴포넌트에서 사용할 수 있었던 상태 접근에 대해 이제 잘게 부서진 컴포넌트 내에서 사용할 수 있게 만들어주어야하기 때문이다. 이러한 상황에 대해 props라는 개념이 대두한다. 부모 컴포넌트로 부터 필요한 속성을 받는 것이다. 다만 이는 다른 문제를 야기하게 됐는데 그게 바로 props drilling이라는 문제였다. 중간에 끼인 컴포넌트 입장에선 실제로 자신이 사용하지 않는 데이터를 오로지 하위 컴포넌트에 패스 시키기 위해서 점유하고 있어야 하게 되는데, 그러다보니 불필요한 비용이 발생하게 된 것이다. 이러한 문제를 해결하기 위해 결국 전역 상태 관리가 출현한다. 

모던 프레임워크에서 상태 관리 라이브러리함은 보다 정확하게는 전역 상태 관리 라이브러리를 의미한다. 물론 실제 사용을 지역적으로 할 수도 있겠지만, 접근 가능하게 열어주기만 하면 모든 View에서 접근 가능하다는 점을 고려할 때 전역 상태 관리 라이브러리 봄이 보다 의미상 맞다고 생각한다. 

그럼 props drilling을 피하기 위해 사용하는 전역 상태는 어떻게 사용하는 것이 바람직할까? 맥락상 접근 가능한 범위에서의 의도적인 지역적 사용이 적합하다고 생각한다. 그 이유는 원래의 MVC가 의도한 바와 같다. SPA라고 한들, 실제로 내부적인 개념으로는 라우팅이 존재하며 여러 개의 페이지가 존재한다. 페이지는 사실상 하나의 큰 맥락이다. 이러한 정보들은 맥락 별로 관리되며, 또한 보존된다. 클라이언트에서 모든 것을 처리하는 SPA 상 항상 고민되는 부분은 ViewModel과 Model의 명시적인 분리다. API로 부터 받아온 DAO(Data Access Object)를  DTO(Data Transfer Object)로 변환해서 사용한다고 가정할 때, 우리가 저장하는 전역 상태는 어떤 값일까? DAO라면 View에서 사용할 때마다 매번 수정이 필요하고, DTO라면 서버와 통신이 필요할 때만 저장하면 될 것이다. 그렇기에 전역 상태에 저장해서 사용해야하는 데이터는 DTO다. 외부 통신이 있을 때 우리는 그저 API를 호출하고, 받아온 데이터를 적절한 형태로 변환해서 저장하고 있으면 된다. View에서 사용하기 위한 ViewModel은 별개의 상태다. (old, new data를 이렇게 썼다면 정말 좋았을텐데….)
